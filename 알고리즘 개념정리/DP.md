# 동적계획법

<aside>
💡 1. 재귀호출과 메모이제이션
2. 동적 계획법

</aside>

## 피보나치 수열

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/0YRl3/btrhKLlr9QX/eKlwtKaAqMogyl0zI0LOZk/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/0YRl3/btrhKLlr9QX/eKlwtKaAqMogyl0zI0LOZk/img.png)

피보나치 수열을 재귀 구현 했을 때 질문

- 얼마나 중복되었나?
- 중복을 피할 수 있는 방법은 무엇인가?

⇒ 이미 처리된(계산된) 결과값을 저장해두고 재사용 하자 !

⇒ 메모이제이션

## 메모이제이션

메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다.

`동적계획법의 핵심` 이 되는 기술이다.

- 추가적인 메모리 공간이 필요하다
- 재귀 함수 호출로 인한 시스템 호출 스택을 사용하게 되고 실행속도 저하 또는 오버플로우가 발생할 수 있다.

## 동적 계획법

동적 계획법은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘

먼저 작은 부분 문제들의 해들을 구하고 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법

### 동적 계획법의 적용 요건

- 중복 부분문제 구조 : 동일한 부분문제들로 구성되어 있나?
    - 순환적인 관계를 명시적으로 표현하기 위해 동적 계획법에서는 일반적으로 수학적 도구인 `점화식`을 사용한다.
- 최적 부분문제 구조 : 부분문제들이 최적이 되면 전체적으로 최적의 해를 구할수 있나?

### 분할 정복과 DP 비교

- 분할 정복
    
    → 대부분 중복 부분문제 구조가 아님.→ 저장할 필요 X→메모이제이션X
    
    - 연관 없는 부분문제로 분할
    - 부분문제를 재귀적으로 해결
    - 부분문제의  해를 결합한다. ex) 병합 정렬
    - 하향식 방법 접근
- DP
    - 부분문제들이 연관이 없으면 적용 X
    - 모든 부분문제를 한번만 계산하고 결과를 저장하고 재사용함.
    - 상향식 방법 접근(일반적으로)

### DP 적용 접근 방법

1. 하향식 접근 시도
2. 각 문제들 인과관계 → 재귀 표현해보기
3. 중복 여부 체크해보기
4. 재귀 → 점화식으로 바꿔보기

- 최적해 구조의 특성을 파악하기
    - 문제를 부분 문제로 나누기
- 최적해의 값을 재귀적으로 정의
    - 부분문제의 최적해 값에 기반하여 문제의 최적해 값을 정의
- 상향식 방법으로 최적해의 값을 계산
    - 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장
        - 재귀 기저처럼 생각해서 값을 직접 결정해서 저장
    - 테이블에 저장되어 있는 부분 문제의 해를 이용해서 점차적으로 상위 부분 문제의 최적해를 구하기 (상향식 방법)

---

보통 dp는 상향식으로 푼다. 하지만 상황에 따라 하향식을 쓸 때도 있다.

 

| 종류 | 특징 | 장점 | 단점 |
| --- | --- | --- | --- |
| 하향식(Top-Down | 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식(재귀) 분할정복과 비슷, 다만 중복되는 작은 문제들을 한번만 품. | 작은 문제들의 결과값을 저장함으로써 동일한 계산을 반복하지 않아 시간 복잡도 감소 | 스택 오버플로우 발생 가능성 |
| 상향식(Bottom-Up) | 작은 문제부터 차례대로 해결해 나가는 방식(반복문) | 부분 문제의 해를 저장하고 이를 활용하여 다음 문제를 해결함으로써 시간 복잡도 감소 | 초기값을 설정해줘야 하고, 작은 문제들의 결과값을 임시적으로 저장해 둘 공간이 필요하다.  |

피보나치 top-down

```java
public class TopDownDP {
    static int[] dp = new int[100];

    public static int fib(int n) {
        if (n <= 1) {
            return n;
        }
        if (dp[n] != 0) { // 메모이제이션
            return dp[n];
        }
        dp[n] = fib(n - 1) + fib(n - 2);
        return dp[n];
    }

    public static void main(String[] args) {
        int n = 10;
        System.out.println("fibonacci(" + n + ") = " + fib(n));
    }
}
```

피보나치 botton-up

```java
public int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    int[] memo = new int[n+1];
    memo[0] = 0;
    memo[1] = 1;
    for (int i = 2; i <= n; i++) {
        memo[i] = memo[i-1] + memo[i-2];
    }
    return memo[n];
}
```

---